# -*- coding: utf-8 -*-
"""
Created on Mon Nov 14 15:47:32 2022

@author: Michael
#References:
# https://github.com/jkrusina/SoccerPredictor
# https://github.com/mhaythornthwaite/Football_Prediction_Project
"""



from os.path import dirname, realpath, sep, pardir
import sys
sys.path.append(dirname(realpath(__file__)) + sep + pardir + sep)

import time
start=time.time()

import pandas as pd
import pickle
import numpy as np
import math
from ml_functions.feature_engineering_functions import average_stats_df, mod_df

from plotly.offline import download_plotlyjs, init_notebook_mode,  plot

import plotly.express as px
import plotly.graph_objects as go
init_notebook_mode()
import matplotlib.pyplot as plt

#INPUT VARIABLES

fixtures_saved_name = '2019_2020_2021_2022_premier_league_fixtures_df.csv'

stats_dict_saved_name = '2019_2020_2021_2022_prem_all_stats_dict.txt'

df_10_saved_name = '2019_2020_2021_2022_prem_df_for_ml_10_v2.txt'

path_to_model = 'C:/Users/Michael/Documents/MACF courses material/Fall 2022/STAT 497/Final Project/Template code/Football_Prediction_Project/ml_model_build_xgBoost/xgboost_model_10.pk1'



# FEATURE ENGINEERING 

with open(f'../prem_clean_fixtures_and_dataframes/{stats_dict_saved_name}', 'rb') as myFile:
    game_stats = pickle.load(myFile)
    
#creating a list with the team id in
team_list = []
for key in game_stats.keys():
    team_list.append(key)
team_list.sort()

#creating a dictionary with the team id as key and fixture id's as values
team_fixture_id_dict = {}
for team in team_list:
    fix_id_list = []
    for key in game_stats[team].keys():
        fix_id_list.append(key)
    fix_id_list.sort()
    sub_dict = {team:fix_id_list}
    team_fixture_id_dict.update(sub_dict)
    
#creating the same dictionary as above but only with the previous 10 games ready for predictions.
team_fixture_id_dict_reduced = {}
for team in team_fixture_id_dict:
    team_fixture_list_reduced = team_fixture_id_dict[team][-10:]
    sub_dict = {team:team_fixture_list_reduced}
    team_fixture_id_dict_reduced.update(sub_dict)

df_10_upcom_fix_e = average_stats_df(10, team_list, team_fixture_id_dict_reduced, game_stats, making_predictions=True)
df_10_upcom_fix = mod_df(df_10_upcom_fix_e, making_predictions=True)

#loading fixtures dataframe, we will work with the clean version.
fixtures_clean = pd.read_csv(f'../prem_clean_fixtures_and_dataframes/{fixtures_saved_name}')

#creating a df with unplayed games only
played_games = []
for i in range(0, len(fixtures_clean)):
    if math.isnan(fixtures_clean['Home Team Goals'].iloc[i]) == False:
        played_games.append(i)
  
unplayed_games = fixtures_clean#.drop(fixtures_clean.index[played_games])
unplayed_games = unplayed_games.reset_index(drop=True)
unplayed_games = unplayed_games.drop(['Home Team Goals', 'Away Team Goals'], axis=1)

#loading df for the labels 
with open(f'../prem_clean_fixtures_and_dataframes/{df_10_saved_name}', 'rb') as myFile:
    df_ml_10 = pickle.load(myFile)

column_list = df_ml_10.columns.tolist()

#instatiating the df for predictions with zeros
df_for_predictions = pd.DataFrame(np.zeros((68, 14)))
df_for_predictions.columns = column_list[:14]

#adding the home and away team id
df_for_predictions = pd.DataFrame(np.zeros((len(unplayed_games), 14)))
df_for_predictions.columns = column_list[:14]
df_for_predictions['Home Team ID'] = unplayed_games['Home Team ID']
df_for_predictions['Away Team ID'] = unplayed_games['Away Team ID']
df_for_predictions['Home Team'] = unplayed_games['Home Team']
df_for_predictions['Away Team'] = unplayed_games['Away Team']
df_for_predictions['Game Date'] = unplayed_games['Game Date']


# ---------- MODELLING MISSING GAME DATA ----------
#if our newly promoted team has not yet played 10 games we need to fill in this gap in order to make a prediction. Lets take the 3 relegated teams, avergae these and use that for all newly promoted teams. 

relegated_id_1 = 35
relegated_id_2 = 38
relegated_id_3 = 71

rel_1_df = (df_10_upcom_fix.loc[df_10_upcom_fix['Team ID'] == relegated_id_1]).reset_index(drop=True)
rel_2_df = (df_10_upcom_fix.loc[df_10_upcom_fix['Team ID'] == relegated_id_2]).reset_index(drop=True)
rel_3_df = (df_10_upcom_fix.loc[df_10_upcom_fix['Team ID'] == relegated_id_3]).reset_index(drop=True)

average_df = rel_1_df.add(rel_2_df, fill_value=0)
average_df = average_df.add(rel_3_df, fill_value=0)
average_df = average_df.div(3)


# ---------- POPULATING 'df_for_predictions' WITH STATS ----------

for i in range(0, len(unplayed_games)):
    #getting home team id and index
    home_team = unplayed_games['Home Team ID'].iloc[i]
    home_team_index = df_10_upcom_fix[df_10_upcom_fix['Team ID']==home_team].index.values
    
    #getting away team id and index
    away_team = unplayed_games['Away Team ID'].iloc[i]
    away_team_index = df_10_upcom_fix[df_10_upcom_fix['Team ID']==away_team].index.values    
    
    #getting the home and away team stats given the index of the teams. This still a df. To replace in the df_for_predictions we need this to be a list. This turns out to be quite complex (steps 2 through to 5).
    #if the team is newly promoted they will not have any stats in df_10_upcom_fix. If this is the case we need to replace the missing data with modelled data
    team_ids = list(df_10_upcom_fix['Team ID'])
    
    if home_team in team_ids:
        h1 = df_10_upcom_fix.iloc[home_team_index]
    else:
        h1 = average_df
        
    if away_team in team_ids:
        a1 = df_10_upcom_fix.iloc[away_team_index]
    else:
        a1 = average_df
    
    
    h2 = h1.T
    a2 = a1.T
    
    h3 = h2.values.tolist()
    a3 = a2.values.tolist()
    
    h4 = []
    for j in range(0, len(h3)):
        h4.append(h3[j][0])

    a4 = []
    for k in range(0, len(a3)):
        a4.append(a3[k][0])
        
    h5 = h4[0:7]
    a5 = a4[0:7]
    
    df_for_predictions.iloc[i, 0:7] = h5
    df_for_predictions.iloc[i, 7:14] = a5


#--------------------------- MAKING THE PREDICTIONS ---------------------------
with open(path_to_model, 'rb') as myFile:
    clf = pickle.load(myFile)

df_for_predictions_r = df_for_predictions.drop(['Home Team ID', 'Away Team ID', 'Home Team', 'Away Team', 'Game Date'], axis=1)

df_for_predictions_r = df_for_predictions_r.drop(['Team Av Shots Diff', 
                    'Opponent Av Shots Diff', 'Team Av Possession Diff', 'Opponent Av Possession Diff'], axis=1)

predictions_raw = clf.predict_proba(df_for_predictions_r)

predictions_df = pd.DataFrame(data=predictions_raw, 
                              index=range(0, len(predictions_raw)), 
                              columns=['Away Win', 'Draw', 'Home Win'])

predictions_df[predictions_df.select_dtypes(include=['number']).columns] *= 100
predictions_df = predictions_df.round(1)

predictions = pd.concat([unplayed_games, predictions_df], axis=1, join='inner')

re_order_cols = ['Home Team', 'Away Team', 'Home Win', 'Draw', 'Away Win', 'Game Date', 'Venue', 'Home Team Logo', 'Away Team Logo', 'Home Team ID', 'Away Team ID', 'Fixture ID', 'index']
    
predictions = predictions.reindex(columns=re_order_cols)

with open('pl_predictions.csv', 'wb') as myFile:
    pickle.dump(predictions, myFile)  
with open('../web_server/pl_predictions.csv', 'wb') as myFile:
    pickle.dump(predictions, myFile)  





#https://plotly.com/python/roc-and-pr-curves/
epl_2021_2022 =  pd.read_csv("C:/Users/Michael/Documents/MACF courses material/Fall 2022/STAT 497/Final Project/Data/Season 2021-2022.csv")


epl_2022_2023 =  pd.read_csv("C:/Users/Michael/Documents/MACF courses material/Fall 2022/STAT 497/Final Project/Data/Season 2022-2023.csv")

epl_2021_2023 = pd.concat([epl_2021_2022, epl_2022_2023])
epl_2021_2023.rename(columns = { 'Date': 'Game Date', 'AwayTeam':'Away Team',
                              'HomeTeam':'Home Team'}, inplace = True)

epl_2021_2023['Game Date'] = pd.to_datetime(epl_2021_2023['Game Date']).dt.date

def arbitrage_scraper(stake,underdog,favourite, draw):
    underdog_amount = ((stake)*(underdog))
    favourite_amount = ((stake)*(favourite))
    draw_amount =  ((stake)*(draw))
    profit = (stake) - (underdog_amount + favourite_amount+ draw_amount)
    margin = (profit/ stake)*100
    
    bid =pd.DataFrame({'leg_1': underdog_amount,'leg_2': favourite_amount, 'leg_3': draw_amount, 'profit': profit,'margin': margin})
    return bid

betting_odds_prob = 1 / epl_2021_2023[epl_2021_2023.columns[42:45]]

home_odds = betting_odds_prob.filter(regex='H$',axis=1)
draw_odds = betting_odds_prob.filter(regex='D$',axis=1)
away_odds = betting_odds_prob.filter(regex='A$',axis=1)

leg_1 = home_odds.min(axis=1)
leg_2 = draw_odds.min(axis=1)
leg_3 = away_odds.min(axis=1)



bid = arbitrage_scraper(1, leg_1, leg_2,leg_3)
arbitrge_odds = bid[bid['margin'] >0 ]

arbitrge_odds.describe()

predictions['Game Date'] = pd.to_datetime(predictions['Game Date']).dt.date

# mergin predictions odds and bokkmakers'odd
played_matches = pd.merge(predictions, epl_2021_2023, how = 'inner', on = ['Game Date','Away Team','Home Team'])


home_odds = played_matches.filter(regex='H$',axis=1)
draw_odds = played_matches.filter(regex='D$',axis=1)
away_odds = played_matches.filter(regex='A$',axis=1)

played_matches['MinOddH'] = home_odds.min(axis=1)
played_matches['MinOddD'] = draw_odds.min(axis=1)
played_matches['MinOddA'] = away_odds.min(axis=1)


played_matches[['MinH','MinD','MinA']] = (1 / played_matches[['MinOddH','MinOddD','MinOddA']])*100



temp = played_matches[(played_matches['Home Win'] < played_matches['MinH']) &
               (played_matches['Draw'] < played_matches['MinD']) &
               (played_matches['Away Win'] < played_matches['MinA']) ]

played_matches[['Home Win','Draw','Away Win','MinOddH','MinOddD','MinOddA']]


def kellyBetStake(stake, MinOddH,MinOddD,MinOddA, MinProbH, MinProbD, MinProbA):
    home_amount = ((MinOddH) * (MinProbH/100) - (1-MinOddH))/(MinOddH)
    
    draw_amount = ((MinOddD) * (MinProbD/100) - (1-MinOddD))/(MinOddD)
    
    away_amount = ((MinOddA) *(MinProbA/100) - (1-MinOddA))/(MinOddA)
    
    
    kelly_bet_size =pd.DataFrame({'home_stake': home_amount,'draw_stake': draw_amount, 'away_stake': away_amount})
    profit = MinProbH * (MinOddH*home_amount- stake) +   MinProbD * (MinOddD*draw_amount- stake) +MinProbA * (MinOddA*away_amount- stake)
    return kelly_bet_size, profit


kellyBetStake(1, played_matches['MinOddH'], played_matches['MinOddD'],played_matches['MinOddA'],
              played_matches['Home Win'],played_matches['Draw'], played_matches['Away Win'] )


kellyBetStake(1, temp['MinOddH'], temp['MinOddD'],temp['MinOddA'],
              temp['Home Win'],temp['Draw'], temp['Away Win'] )

#kellyBetStake(played_matches['MinOddH'], played_matches['MinOddD'],played_matches['MinOddA'],
#              played_matches['MinH'],played_matches['MinD'], played_matches['MinA'] )


# plot 'Distribution of Arbitrages Profit Margin'
fig = go.Figure()
fig.add_trace(go.Violin( y=bid['margin'], box_visible=True,
                               meanline_visible=True, opacity=0.6,
                               x0='Profit Margin',side='negative', scalegroup='Yes', name='Margin for all Matches',
                               line_color='blue', width=600, ))


fig.add_trace(go.Violin( y=arbitrge_odds['margin'], box_visible=True, 
                               meanline_visible=True,  opacity=0.6,scalegroup='No', name='Margin for Arbitrage',
                               x0='Profit Margin', side='positive', line_color='orange', width=600,))

fig.update_layout(
    title = 'Distribution of Arbitrages Profit Margin',
    #xaxis_title = 'Outcome',
    yaxis_title='Profit Margin'
    , width=600, height=400, )

fig.update_layout(
    legend=dict(
        x=0,
        y=1,
        traceorder="normal",
        font=dict(
            family="sans-serif",
            size=12,
            color="black"
        ),
    )
)

fig.update_traces(meanline_visible=True)
fig.update_layout(violingap=0, violinmode='overlay')
plot(fig)


# polar graph for importance features vs fl_5
fig = go.Figure()

fig = px.line_polar(fi_ml_10, r="importance", theta="feature", line_close=True,
                    color_discrete_sequence=px.colors.sequential.Plasma_r,
                    template="plotly_dark")
plot(fig)

##################################################
# comparison odds vs predicted odds metrics

predicted_probabilities = played_matches[['Home Win','Draw','Away Win']]
avg_odds_offered = (1/ played_matches[['AvgH', 'AvgD', 'AvgA' ]]) *100
odds_offered = (1/ played_matches[['B365H','B365D','B365A']]) *100

comp_odds = ((np.array(predicted_probabilities) - np.array(avg_odds_offered))/np.array(predicted_probabilities))*100

comp_odds = pd.DataFrame(data=comp_odds)
comp_odds.columns =['Home_diff', 'Draw_diff', 'Away_diff']
comp_odds.describe()




# Create scatterplot

plt.scatter( odds_offered, predicted_probabilities)

ci = 0.5 * np.std([0, 100])/np.sqrt(len([0, 100]))

# Add line y=x
plt.plot([0, 100], [0, 100], color="red")
plt.fill_between([0, 100], ([0, 100]-ci), ([0, 100]+ci), color='b', alpha=.1)

# Add labels and title
plt.ylabel("Predicted Probability")
plt.xlabel("Probability of Odds Offered")
plt.title("Biases Odds Opportunities with Error Margin")

# Show plot
plt.show()


# Box plot
#'Predicted Odds VS Bookmakers Odds (in %)'

fig = px.box(comp_odds, width=500, height=400,  )
fig.update_layout(
    xaxis_title = 'Outcome',
    yaxis_title='Spread')
plot(fig)

######################################################




